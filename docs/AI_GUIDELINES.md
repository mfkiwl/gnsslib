# ★ GNSSLIB 프로젝트 AI 작업 가이드라인

이 문서는 GNSSLIB 프로젝트에서 AI가 코드 작성, 문서화, 리팩토링 등의 작업을 수행할 때 지켜야 할 규칙들을 정의합니다.

## ■ 목차

1. [기본 원칙](#-1-기본-원칙)
   - 1.1 [언어 및 소통](#-11-언어-및-소통)
   - 1.2 [플랫폼 호환성](#-12-플랫폼-호환성)

2. [C 언어 코딩 스타일](#-2-c-언어-코딩-스타일)
   - 2.1 [네이밍 컨벤션](#-21-네이밍-컨벤션)
   - 2.2 [구조체 정의](#-22-구조체-정의)
   - 2.3 [헤더 파일 관리](#-23-헤더-파일-관리)

3. [문서화 규칙](#-3-문서화-규칙)
   - 3.1 [마크다운 문서](#-31-마크다운-문서)
   - 3.2 [수학 표기법](#-32-수학-표기법)
   - 3.3 [함수 문서화 분리](#-33-함수-문서화-분리)

4. [코드 품질 관리](#-4-코드-품질-관리)
   - 4.1 [코드 구조](#-41-코드-구조)
   - 4.2 [컴파일 및 검증](#-42-컴파일-및-검증)
   - 4.3 [리팩토링 원칙](#-43-리팩토링-원칙)
   - 4.4 [메모리 관리](#-44-메모리-관리)

5. [예외 처리 및 디버깅](#-5-예외-처리-및-디버깅)
   - 5.1 [오류 처리](#-51-오류-처리)
   - 5.2 [코드 가독성](#-52-코드-가독성)

---

## ▲ 1. 기본 원칙

### ◆ 1.1 언어 및 소통
- **항상 한국어로 응답**
- 협업에서 통용되는 관행을 따름
- 효율적이고 간결하고 우아한 방식을 추구

### ◆ 1.2 플랫폼 호환성
- **Windows, Mac, Linux 모두 호환** 가능한 코드 작성
- C 표준 라이브러리 우선 사용
- 플랫폼별 조건부 컴파일 필요시 적절히 활용

## ▲ 2. C 언어 코딩 스타일

### ◆ 2.1 네이밍 컨벤션
```c
// Functions: PascalCase
void InitNav(nav_t *nav);
int Prn2Sat(int sys, int prn);

// Variables: camelCase or lowercase
int satIndex, matrixData, nsat;

// Constants: UPPER_SNAKE_CASE
#define MAX_PRN_GPS 32
#define FREQ_L1 1575.42e6

// Structures/Types: camelCase + _t suffix
typedef struct leapSec {
    // ...
} leapSec_t;

typedef struct satStr {
    char str[SAT_STR_SIZE];
} satStr_t;
```

### ◆ 2.2 구조체 정의
- 멤버 변수는 적절한 들여쓰기와 정렬로 가독성 확보
- 주석은 각 멤버의 역할과 단위를 명시
- 기본값 초기화는 구조체 정의가 아닌 사용 시점에서 수행

### ◆ 2.3 헤더 파일 관리
- **순환 참조 절대 금지**
- 헤더에는 선언에 필요한 최소한의 헤더만 포함
- 구현 파일로 가능한 많은 헤더 이동
- 내부 프로젝트 헤더는 외부 시스템 헤더 이후에 포함

## ▲ 3. 문서화 규칙

### ◆ 3.1 마크다운 문서
- **C코드에 해당하는 마크다운 Docs 작성 필수**
- **해당 C코드 또는 헤더에 포함된 내용만 작성 → 없는 내용은 작성 금지**
- **이모티콘 대신 특수문자 활용** (★, ▲, ◆, ■, □ 등)
- 제목 단계에 따라 특수문자 통일 사용
- **인라인 수식은 `$~$` 형식** 사용 (LaTeX 호환성)
- 내용 순서는 목차 → 기본 개념 → 데이터 타입 트리 구조 → 데이터 타입 목록 → 함수 트리 구조 → 함수 목록 → 사용 예시 → 성능 특성 순으로 작성
- 기본 개념은 해당 코드의 구조나 방식, 특징을 기입 (수식 필요 시 적절히 사용) (예: column major 저장방식, 메모리 관리 체계, 위성 인덱스 시스템, GNSS 관측 코드 구조, 인덱스 매핑 시스템, 설계 철학 등)
- 데이터 타입 목록은 해당 헤더파일에 명시된 구조체 변수에 대한 설명 기입. 각 데이터 타입 설명글은 글 펼치기 기능을 이용할 것
- 함수 목록은 해당 헤더파일에 명시된 함수에 대한 설명 기입 (수식 필요 시 적절히 사용) (수행 목적, 인풋, 아웃풋, 로직). 각 함수 설명글은 글 펼치기 기능을 이용할 것

#### 데이터 타입 트리 구조 규칙
```
## ▲ 데이터 타입 구조

모듈명 타입 계층
├── 주요 카테고리 1
│   ├── type1_t ──────────── 타입 간단 설명
│   ├── type2_t ──────────── 타입 간단 설명
│   └── type3_t ──────────── 타입 간단 설명
├── 주요 카테고리 2
│   ├── typeA_t ──────────── 타입 간단 설명
│   └── typeB_t ──────────── 타입 간단 설명
└── 기타 관련 데이터
    ├── 배열[SIZE] ────────── 배열 형태 데이터
    └── 기본 타입 ──────────── int, double 등
```

**규칙**:
- ASCII 트리 구조로 계층 관계 표현
- 들여쓰기는 │, ├, └ 문자 사용
- 타입명 뒤에 ─ 문자로 정렬하여 설명 추가
- 간단 설명의 시작 위치를 동일한 열로 정렬
- 관련 있는 타입들을 카테고리별로 그룹핑
- 구조체는 `type_t` 형태, 배열은 `배열[SIZE]` 형태로 표기

#### 함수 트리 구조 규칙
```
## ▲ 함수 구조

모듈명 함수 계층
├── 주요 기능 카테고리 1
│   ├── Function1() ──────── 함수 간단 설명
│   ├── Function2() ──────── 함수 간단 설명
│   └── Function3() ──────── 함수 간단 설명
├── 주요 기능 카테고리 2
│   ├── 세부 기능 그룹
│   │   ├── FuncA() ──────── 함수 간단 설명
│   │   ├── FuncB() ──────── 함수 간단 설명
│   │   └── FuncC() ──────── 함수 간단 설명
│   └── 기타 함수
│       ├── FuncX() ──────── 함수 간단 설명
│       └── FuncY() ──────── 함수 간단 설명
└── 유틸리티 함수
    ├── UtilFunc1() ──────── 함수 간단 설명
    └── UtilFunc2() ──────── 함수 간단 설명
```

**규칙**:
- ASCII 트리 구조로 기능별 계층 관계 표현
- 들여쓰기는 │, ├, └ 문자 사용
- 함수명 뒤에 ─ 문자로 정렬하여 설명 추가
- 간단 설명의 시작 위치를 동일한 열로 정렬
- 관련 기능별로 카테고리 그룹핑
- 세부 기능이 많은 경우 하위 그룹으로 세분화
- 함수명은 `Function()` 형태로 괄호 포함

#### 데이터 타입 목록 구조화 규칙
```
#### ▲ 데이터 타입 목록

##### ◆ type_t (enum)
<details>
<summary>상세 설명</summary>

**목적**: ...
**정의**: ...
**값**: ...
**사용**: ...

</details>
```

#### 함수 목록 구조화 규칙
```
#### ▲ 함수 목록

##### ◆ 기본 생성/해제 함수

#### ● Mat() - 행렬 생성
<details>
<summary>상세 설명</summary>

**목적**: ...
**입력**: ...
**출력**: ...
**함수 로직**: ...

</details>
```

### ◆ 3.2 수학 표기법
- **벡터**: 소문자 + 볼드 + 이탤릭 → `$\boldsymbol{a}$`
- **스칼라**: 소문자 + 이탤릭 → `$a$`
- **행렬**: 대문자 + 볼드 → `$\mathbf{A}$`
- **영어 단어 변수**: `$\text{GPST}$`, `$\text{week}$`, `$\text{tow}$`

>**예시**: 위성-수신기 간 거리 계산 공식
>
> $$\rho_r^s = \sqrt{(x_s - x_r)^2 + (y_s - y_r)^2 + (z_s - z_r)^2} + \frac{\omega_e}{c}\cdot(x^sy_r-x_ry^s) $$
>
> **변수 설명:**
> - $\rho_r^s$: 위성-수신기 간 거리
> - $\boldsymbol{r}^s = [x^s, y^s, z^s]^{\top}$: 위성 위치 벡터
> - $\boldsymbol{r}_r = [x_r, y_r, z_r]^{\top}$: 수신기 위치 벡터
> - $c$: 광속
> - $\omega_e$: 지구 자전 속도


### ◆ 3.3 함수 문서화 분리
- **헤더 파일**: 상세한 API 문서 (args, return 포함)
- **구현 파일**: 간단한 한 줄 주석

```c
// 헤더 파일 예시
// -----------------------------------------------------------------------------
// Convert satellite PRN and system index to satellite index
//
// args:
//        int   sys     (I) : satellite system index
//        int   prn     (I) : satellite PRN number
//
// return:
//        int   sat     (O) : satellite index (0 if error)
// -----------------------------------------------------------------------------
int Prn2Sat(int sys, int prn);

// 구현 파일 예시
// Convert satellite PRN and system index to satellite index
int Prn2Sat(int sys, int prn)
{
    // Implementation...
}
```

## ▲ 4. 코드 품질 관리

### ◆ 4.1 코드 구조
- 가독성, 직관성 효율성을 적절히 고려할 것
- **성능보다 안정성 우선**

### ◆ 4.2 컴파일 및 검증
- 변경 후 반드시 컴파일 검증
- 경고 메시지 최소화
- 오류 발생 시 3회 이내 수정 시도

### ◆ 4.3 리팩토링 원칙
- 기능 변경 없이 구조 개선
- 단계적 접근 (한 번에 하나의 모듈)
- 순환 참조 해결 우선

### ◆ 4.4 메모리 관리
- 동적 할당 시 반드시 해제 함수 제공
- 초기화 함수와 해제 함수 쌍으로 설계
- NULL 포인터 검증 철저히 수행

## ▲ 5. 예외 처리 및 디버깅

### ◆ 5.1 오류 처리
- 함수 반환값으로 성공/실패 상태 전달
- 인덱스류 (sat, rcv, band, code, ...) 반환 함수 → 0: 오류
- double 반환 함수 → 0.0: 오류
- 포인터류 반환 함수 → NULL: 오류
- **위 규칙을 지키지 못하는 경우 함수 설명 주석에 기입 필수**
- 입력 검증을 통한 방어적 프로그래밍

### ◆ 5.2 코드 가독성
- 복잡한 로직은 주석으로 설명
- 매직 넘버 대신 명명된 상수 사용
- 함수는 하나의 책임만 가지도록 설계

---

**■ 이 가이드라인은 GNSSLIB 프로젝트의 일관성과 품질을 보장하기 위한 필수 규칙입니다.**
**■ 모든 AI 작업은 이 규칙을 준수하여 수행되어야 합니다.**
